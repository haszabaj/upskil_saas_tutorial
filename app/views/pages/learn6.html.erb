<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
</head>
<body>

<div class="container">
  <h2>Ruby commands</h2>
  <table class="table table-striped">
    <thead>
      <tr>
        <th>Command</th>
        <th>Use</th>
      </tr>
    </thead>
    <tbody>
      <tr>
            <td>Addition (+)</br>
                Subtraction (-) </br>
                Multiplication (*) </br>
                Division (/) </br>
                Exponentiation (**) </br>
                Modulo (%)</td>
            <td>Mathematical equations: exponentation: potÄ™ga, modulo: reszta</td>
        </tr>
         <tr>
            <td>"...".length</td>
            <td>Counts the number of characters in a string</td>
        </tr>
         <tr>
            <td>"...".reverse</td>
            <td>Reverses the string</td>
        </tr>
        <tr>
            <td>#</td>
            <td>Comment, no closing!</td>
        </tr>
        <tr>
            <td>=begin</br>Comment</br>Comment</br>=end</td>
            <td>Multi-lined comments</td>
        </tr>
        <tr>
            <td>my_num =     25</br>my_boolean =     true</br>my_string =     "Ruby"</td>
            <td>Setting values</td>
        </tr>
        <tr>
            <td>print "Ruby"</td>
            <td>Displaying content on the screen, the difference between "puts" and print is that after puts there's a new line.</td>
        </tr>
        <tr>
            <td>variable= gets.chomp</td>
            <td>Gets = inquires content from user </br>Chomp = addes new line after each bit of input</td>
        </tr>
        <tr>
            <td>variable= gets.chomp</br>puts "Your name is #{variable}"</td>
            <td>String interpolation</td>
        </tr>
        <tr>
            <td><xmp>print "What is your state/province?"
                    state = gets.chomp
                    state2 = state.upcase
                    state.upcase!
                    puts = "Your name is #{first_name} #{last_name}. You come from #{city} in #{state}.</xmp></td>
            <td>state = input by user, state2 = display of input in puts. commend "!" setting an answer. </td>
        </tr>
        <tr>
                    <td><xmp>if 1 > 2
                    print "I won't get printed because one is less than two."
                    end </xmp></td>
            <td>if the condition is met, program puts the value ("true"), if not ignores this part of code </td>
        </tr>
        <tr>
                    <td><xmp>if 1 > 2
                    print "Value"
                    else
                    print "Other_Value"
                    end </xmp></td>
            <td>if the condition is met, program puts the value ("true"), if not, puts the other value </td>
        </tr>
         <tr>
                    <td><xmp>if x < y  # Assumes x and y are defined
                    puts "x is less than y!"
                    elsif x > y
                    puts "x is greater than y!"
                    else
                    puts "x equals y!"
                    end</xmp></td>
            <td>if the condition is met, program puts the value ("true"), if not, checks for another condition, if all is false puts else. </td>
        </tr>
            <tr>
                <td><xmp>unless hungry
                puts "value"
                else
                puts "value2"
                end</xmp></td>
            <td>if the condition is not met, program puts the value ("true"), if not puts else. </td>
        </tr>
        <tr>
            <td><xmp>x = 2
                        y = 2
                        x == y
                        x != z
                        print "x and y are equal!"
                        end</xmp></td>
            <td>== equals, != does not equal</td>
        </tr>
        <tr>
            <td> ></br><</br>>=</br><=</td>
            <td>Other options</td>
        </tr>
        <tr>
            <td>true && true # => true</td>
            <td>Double condition must be met</td>
        </tr>
         <tr>
            <td>true || true # => true</td>
            <td>One or OTHER condition must be met</td>
        </tr>
         <tr>
            <td><xmp>!true # => false
            !false # => true</xmp></td>
            <td>! means not_value</td>
        </tr>
        <tr>
            <td><xmp>print "Tell me what to thay?"
            user_input = gets.chomp
            user_input.downcase!
            if user_input.include? "s"
            print "It found s"
            end</xmp></td>
            <td>include? checks for a string part in a chosen string</td>
        </tr>
        <tr>
            <td><xmp>print "Tell me what to thay?"
            user_input = gets.chomp
            user_input.downcase!
            if user_input.include? "s"
            user_input.gsub!(/s/, "th")
            end
            </xmp></td>
            <td>gsub substitutes parts of the string,  ! commands the answer</td>
        </tr>
         <tr>
            <td><xmp>counter = 1
            while counter < 11
            puts counter
            counter = counter + 1
            end
            </xmp></td>
            <td>while countes for multiples case of if (loop)</td>
        </tr>
        <tr>
            <td><xmp>counter = 1
            for counter in 1..50 do
            print counter
            counter = counter + 1
            end</xmp></td>
            <td>another way to express "while" </td>
        </tr>
        <tr>
            <td><xmp>counter += 1</br>counter -= 1</br>counter /= 1</br>counter *= 1
            </xmp></td>
            <td>Shortcut for counter = counter + 1</td>
        </tr>
        <tr>
            <td><xmp>for num in 1...10</br>for num in 1..10</br>puts num</br>end
            </xmp></td>
            <td>Puts string for values 1-9 (three dots) or 1-10 (two dots)</td>
        </tr>
        <tr>
            <td><xmp>print { "hello world!" }</xmp>
            { stands for do } for end</td>
            <td><xmp>i = 20
            loop do
            i -= 1
            print "#{i}"
            break if i <= 0
            end</xmp></td>
        </tr>
         <tr>
            <td><xmp>  
            loop do 
            i -= 1
            next if i % 2 == 1
            print "#{i}"
            end</xmp></td>
            <td>Next skips a step of the loop if a cndition (i e. the number is odd.</td>
        </tr>
        <tr>
            <td> my_array = [1, 2, 3, 4, 5]</td>
            <td>Declaring an array (set of values)</td>
        </tr>
        <tr>
            <td> my_array[index]</td>
            <td>each item in array has an index - the first item has the index of 0, the 2nd - 1, the 3rd- 2 and so on.</br>Elements in arrays can be adressed by their indexes.</td>
        </tr>
        <tr>
            <td><xmp>array.each do |x|
            x += 10
            print "#{x}"
            end</xmp></td>
            <td>.each signs an action to each element of an array</td>
        </tr>
         <tr>
            <td><xmp>15.times {print "I'm  programmist"}</xmp></td>
            <td>Performs an {action} X.times </td>
        </tr>
        <tr>
            <td><xmp>words = text.split(" ")</xmp></td>
            <td> .split method takes a string and divides it according to the instructions in ("") (in this case split after every space </br>
            This way we get an array containing the elements of the string. </td>
        </tr>
        <tr>
            <td><xmp>my_hash = { "name" => "Eric",</br>
            "age" => 26,
            "hungry?" => true
             }</xmp></td>
             <td>Hash is a set of keys with values put to them</td>
        </tr>
        <tr>
            <td><xmp>newhashname = Hash.new()</xmp></td>
            <td>method to add a new hash (Hash capitalized!)</br>in () we give a default value (that works i.e. if you want to access a non-existing</br>
            key, it shows a default value - if it's a string in goes in ""!</td>
        </tr>
        <tr>
            <td><xmp>pets = Hash.new
            pets["Milo"] = "cat"</xmp></td>
            <td>Adds new key- value pair to the hash</td>
        </tr>
        <tr>
            <td><xmp>array.each { |element| puts element}</xmp></td>
            <td>prints each element of an array - element is not a placeholder name, it actually should ready "element"</td>
        </tr>
        <tr>
            <td><xmp>def method_name(parameter)
            body
            end
            
            method_name(argument)</xmp></td>
            <td>Defying a method - a section of code designed to perform a specific task - after defying it we can always call i by its name</td>
        </tr>
        <tr>
            <td><xmp>def method_name(parameter, *paremeter2)</xmp></td>
            <td>* signalizes that some parameter might have more than one argument assigned = <b>splat argument</b></td>
        </tr>
        <tr>
            <td><xmp>def method_name(parameter, parameter2)
            return parameter 1 + parameter2
            end</xmp></td>
            <td>return is like puts, but allows us to process the content (i.e. mathematical equasions and so on)</td>
        </tr>
        <tr>
            <td><xmp>object1 <=> object2</xmp></td>
            <td>compares two objects - if the value is 1, object2 should come in front of object1</br>
            if the value is 0, no object comes in front of the other</br>
            if the value is -1, object1 comes in front of object2</td>
        </tr>
        <tr>
            <td><xmp>def alphabetize(arr, rev=false)
            end</xmp></td>
            <td>In this line we set two parameters, second is a bootlean by default put to "false" - if when calling the method</br>
            we don't specify the second parameter or argument ruby (in this case) assumes it's false</td>
        </tr>
        <tr>
            <td><xmp>my_hash[key]</xmp></td>
            <td>calling a certainkey (or "key") of a defined hash</td>
        </tr>
        <tr>
            <td><xmp>no_nil_hash = Hash.new("It doesn't look like anything to me")</xmp></td>
            <td>By creating new hash we put a default value to be displayed in the place of nil</td>
        </tr>
        <tr>
            <td><xmp>my_symbol = :_symbol</xmp></br>
            or alternativly <xmp>symbol: value (in new syntax)</xmp></td>
            <td>Symbol - name needs to start with an underscore or a letter - symbols make good keys in a hash!</td>
        </tr>
        <tr>
            <td><xmp>symbols.push(s.to_sym)</xmp></td>
            <td>push puts some content to an array (in this case array is symbols - array needs to be craeted before</br>
            s.to_sym - changes content of some hash from strings to symbols/ .intern does the same!</td>
        </tr>
        <tr>
            <td><xmp>variable = hash_name.select do |key, value| value > X
            end</xmp></td>
            <td>Selects only keys with specific value</td>
        </tr>
    </tbody>
  </table>
</div>

</body>
</html>
